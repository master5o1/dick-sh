#!/usr/bin/env zsh

declare -A memory
hand=0

## helper function to parse `8====D` number literals
## also extracts variable values from memory.
_dick_value() {
    local value=0
    if [[ "$1" =~ ^8=*D$ ]]; then
        value=$(($(echo "$1" | grep -o "=" | wc -l)))
        echo $value
        return
    fi
    echo $memory["$1"]
}

## helper function to parse extract HEREDOC and
## de-indent to ensure an inner `EOF` does not
## have preceeding spaces. 
_parse_heredoc_block() {
    local raw=$(cat)
    local ident=`echo $raw | head -n 1 | sed -n 's/^\([[:space:]]*\).*/\1/p'`
    echo $raw | sed "s/^$ident//"
}

DICK() {
    local value=$(_dick_value $2)
    memory["$1"]=$value
}

GRIP() {
    local prompt="$1"
    local input=""
    printf "$prompt ðŸ«³ "
    read input
    while [[ ! "$input" =~ ^8=*D$ ]]; do
        printf "ðŸ˜¡ $prompt ðŸ«³ "
        read input
    done
    hand=$(_dick_value $input)
}

GRAB() {
    hand=$(_dick_value $1)
}

RELEASE() {
    memory["$1"]=$hand
}

LONGDICK() {
    local operand=$(_dick_value $1)
    hand=$((hand + $operand))
}

SMALLDICK() {
    local operand=$(_dick_value $1)
    hand=$((hand - $operand))
}

HUGEDICK() {
    local operand=$(_dick_value $1)
    hand=$((hand * $operand))
}

TINYDICK() {
    local operand=$(_dick_value $1)
    hand=$((hand / $operand))
}
DRIBBLEDICK() {
    local operand=$(_dick_value $1)
    hand=$((hand % $operand))
}

_line_ending() {
    if [[ $1 == "LINE" ]]; then
        printf "\r\n"
    fi
}

PEE() {
    local lineending=""
    if [[ $1 == "LINE" ]]; then
        lineending="\r\n"
    fi
    printf "${hand}${lineending}"
}

WEE() {
    local lineending=""
    if [[ $1 == "LINE" ]]; then
        lineending="\r\n"
    fi
    printf "\x$(printf %x "$hand")${lineending}"
}

STROKE() {
    local block=$(_parse_heredoc_block)
    while [[ $hand -ge 0 ]]; do
        eval "$block"
    done
}

EDGING() {
    local block=$(_parse_heredoc_block)
    if [[ "$hand" -eq 0 ]]; then
        eval "$block"
    fi
}

BAG() {
    local name="$1"
    local block=$(_parse_heredoc_block)

    shift
    for ((i=1; i <= $#; i++)); do
        block="${block//${@[$i]}/\$$i}"
    done

    eval "$name(){;$block;}"
}

__long_dick_conditional() {
    local operand1=$(_dick_value $1)
    local operator=$3
    local operand2=$(_dick_value $5)
    local block=$(_parse_heredoc_block)

    case $operator in
        "BIGGER")
            if [[ $operand1 -gt $operand2 ]]; then
                eval "$block"
            fi
            ;;
        "SMALLER")
            if [[ $operand1 -lt $operand2 ]]; then
                eval "$block"
            fi
            ;;
        "JUST")
            if [[ $operand1 -eq $operand2 ]]; then
                eval "$block"
            fi
            ;;
    esac
}

__long_dick_loop() {
    local operand1=$(_dick_value $1)
    local operand2=$(_dick_value $5)
    local operator=$3
    local block=$(_parse_heredoc_block)

    case $operator in
        "BIGGER")
            while [[ $operand1 -gt $operand2 ]]; do
                eval "$block"
                operand1=$(_dick_value $1)
                operand2=$(_dick_value $5)
            done
            ;;
        "SMALLER")
            while [[ $operand1 -lt $operand2 ]]; do
                eval "$block"
                operand1=$(_dick_value $1)
                operand2=$(_dick_value $5)
            done
            ;;
        "JUST")
            while [[ $operand1 -eq $operand2 ]]; do
                eval "$block"
                operand1=$(_dick_value $1)
                operand2=$(_dick_value $5)
            done
            ;;
    esac
}


__prepocess_long_dick() {
    cat $1 \
      | sed -E 's/LOOK\! (.+)\!/__long_dick_conditional \1 <<CUM/g' \
      | sed 's/DICK JOKES ARE IMMATURE, SERIOUSLY/CUM/g' \
      | sed -E 's/COCK GO FAST IF (.+)\!/__long_dick_loop \1 <<CUM/g' \
      | sed 's/ALRIGHT, STOP COCKING AROUND/CUM/g'
}

if [[ -f $1 ]]; then
    source <(__prepocess_long_dick "$1")
else
    echo "usage: dick program.dick"
fi